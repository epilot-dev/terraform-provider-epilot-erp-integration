// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/epilot-dev/terraform-provider-epilot-erp-integration/internal/sdk/internal/utils"
)

// ReadingMatching - Strategy for matching incoming readings against existing readings.
//   - 'external_id': Match readings by external_id attribute (default behavior)
//   - 'strict-date': Match by meter_id + counter_id + direction + date (German timezone).
//     Useful when readings originate from ECP and are echoed back by the ERP with truncated timestamps.
type ReadingMatching string

const (
	ReadingMatchingExternalID ReadingMatching = "external_id"
	ReadingMatchingStrictDate ReadingMatching = "strict-date"
)

func (e ReadingMatching) ToPointer() *ReadingMatching {
	return &e
}
func (e *ReadingMatching) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "external_id":
		fallthrough
	case "strict-date":
		*e = ReadingMatching(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ReadingMatching: %v", v)
	}
}

// IntegrationMeterReadingMode - Operation mode for meter reading mapping:
// - 'upsert': Create or update meter readings (default)
// - 'delete': Delete the meter reading
// - 'upsert-prune-scope': Upsert readings from array, then delete all other readings for the same meter+counter that weren't upserted
type IntegrationMeterReadingMode string

const (
	IntegrationMeterReadingModeUpsert           IntegrationMeterReadingMode = "upsert"
	IntegrationMeterReadingModeDelete           IntegrationMeterReadingMode = "delete"
	IntegrationMeterReadingModeUpsertPruneScope IntegrationMeterReadingMode = "upsert-prune-scope"
)

func (e IntegrationMeterReadingMode) ToPointer() *IntegrationMeterReadingMode {
	return &e
}
func (e *IntegrationMeterReadingMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "upsert":
		fallthrough
	case "delete":
		fallthrough
	case "upsert-prune-scope":
		*e = IntegrationMeterReadingMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for IntegrationMeterReadingMode: %v", v)
	}
}

type IntegrationMeterReading struct {
	// Optional JSONata expression to extract meter reading items from the event data.
	// If not provided, the entire payload is used as the reading data.
	// Useful when you need to extract an array of readings from a nested structure (e.g., "$.readings").
	//
	JsonataExpression *string `json:"jsonataExpression,omitempty"`
	// Strategy for matching incoming readings against existing readings.
	// - 'external_id': Match readings by external_id attribute (default behavior)
	// - 'strict-date': Match by meter_id + counter_id + direction + date (German timezone).
	//   Useful when readings originate from ECP and are echoed back by the ERP with truncated timestamps.
	//
	ReadingMatching *ReadingMatching `default:"external_id" json:"reading_matching"`
	// Operation mode for meter reading mapping:
	// - 'upsert': Create or update meter readings (default)
	// - 'delete': Delete the meter reading
	// - 'upsert-prune-scope': Upsert readings from array, then delete all other readings for the same meter+counter that weren't upserted
	//
	Mode *IntegrationMeterReadingMode `default:"upsert" json:"mode"`
	// Scope configuration for meter reading upsert-prune-scope mode.
	// The scope is all readings for the same meter + counter.
	//
	Scope        *MeterReadingPruneScopeConfig `json:"scope,omitempty"`
	Meter        MeterUniqueIdsConfig          `json:"meter"`
	MeterCounter *MeterUniqueIdsConfig         `json:"meter_counter,omitempty"`
	// Field mapping definitions for meter reading attributes
	Fields []IntegrationEntityField `json:"fields"`
}

func (i IntegrationMeterReading) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *IntegrationMeterReading) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *IntegrationMeterReading) GetJsonataExpression() *string {
	if i == nil {
		return nil
	}
	return i.JsonataExpression
}

func (i *IntegrationMeterReading) GetReadingMatching() *ReadingMatching {
	if i == nil {
		return nil
	}
	return i.ReadingMatching
}

func (i *IntegrationMeterReading) GetMode() *IntegrationMeterReadingMode {
	if i == nil {
		return nil
	}
	return i.Mode
}

func (i *IntegrationMeterReading) GetScope() *MeterReadingPruneScopeConfig {
	if i == nil {
		return nil
	}
	return i.Scope
}

func (i *IntegrationMeterReading) GetMeter() MeterUniqueIdsConfig {
	if i == nil {
		return MeterUniqueIdsConfig{}
	}
	return i.Meter
}

func (i *IntegrationMeterReading) GetMeterCounter() *MeterUniqueIdsConfig {
	if i == nil {
		return nil
	}
	return i.MeterCounter
}

func (i *IntegrationMeterReading) GetFields() []IntegrationEntityField {
	if i == nil {
		return []IntegrationEntityField{}
	}
	return i.Fields
}
