// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/epilot-dev/terraform-provider-epilot-erp-integration/internal/sdk/internal/utils"
)

type EnabledType string

const (
	EnabledTypeBoolean EnabledType = "boolean"
	EnabledTypeStr     EnabledType = "str"
)

// Enabled - Controls whether this entity mapping should be processed. Can be a boolean or a JSONata expression (string) that evaluates to a boolean.
type Enabled struct {
	Boolean *bool   `queryParam:"inline" union:"member"`
	Str     *string `queryParam:"inline" union:"member"`

	Type EnabledType
}

func CreateEnabledBoolean(boolean bool) Enabled {
	typ := EnabledTypeBoolean

	return Enabled{
		Boolean: &boolean,
		Type:    typ,
	}
}

func CreateEnabledStr(str string) Enabled {
	typ := EnabledTypeStr

	return Enabled{
		Str:  &str,
		Type: typ,
	}
}

func (u *Enabled) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  EnabledTypeBoolean,
			Value: &boolean,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  EnabledTypeStr,
			Value: &str,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Enabled", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Enabled", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(EnabledType)
	switch best.Type {
	case EnabledTypeBoolean:
		u.Boolean = best.Value.(*bool)
		return nil
	case EnabledTypeStr:
		u.Str = best.Value.(*string)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Enabled", string(data))
}

func (u Enabled) MarshalJSON() ([]byte, error) {
	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type Enabled: all fields are null")
}

// Mode - Operation mode for entity mapping:
// - 'upsert': Create or update the entity (default)
// - 'delete': Soft delete the entity (marks as deleted)
// - 'purge': Hard delete the entity (permanent removal)
// - 'upsert-prune-scope-purge': Upsert entities from array, then purge entities in scope that weren't upserted
// - 'upsert-prune-scope-delete': Upsert entities from array, then soft delete entities in scope that weren't upserted
type Mode string

const (
	ModeUpsert                 Mode = "upsert"
	ModeDelete                 Mode = "delete"
	ModePurge                  Mode = "purge"
	ModeUpsertPruneScopePurge  Mode = "upsert-prune-scope-purge"
	ModeUpsertPruneScopeDelete Mode = "upsert-prune-scope-delete"
)

func (e Mode) ToPointer() *Mode {
	return &e
}
func (e *Mode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "upsert":
		fallthrough
	case "delete":
		fallthrough
	case "purge":
		fallthrough
	case "upsert-prune-scope-purge":
		fallthrough
	case "upsert-prune-scope-delete":
		*e = Mode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Mode: %v", v)
	}
}

type IntegrationEntity struct {
	// Target entity schema (e.g., 'contact', 'contract')
	EntitySchema string `json:"entity_schema"`
	// Array of attribute names that uniquely identify this entity.
	// The _type hint for repeatable fields (e.g., email, phone) should be specified
	// on the corresponding field definition in the fields array.
	//
	UniqueIds []string `json:"unique_ids"`
	// Optional JSONata expression to pre-process the event data before field mapping
	JsonataExpression *string `json:"jsonataExpression,omitempty"`
	// Controls whether this entity mapping should be processed. Can be a boolean or a JSONata expression (string) that evaluates to a boolean.
	Enabled *Enabled `json:"enabled,omitempty"`
	// Operation mode for entity mapping:
	// - 'upsert': Create or update the entity (default)
	// - 'delete': Soft delete the entity (marks as deleted)
	// - 'purge': Hard delete the entity (permanent removal)
	// - 'upsert-prune-scope-purge': Upsert entities from array, then purge entities in scope that weren't upserted
	// - 'upsert-prune-scope-delete': Upsert entities from array, then soft delete entities in scope that weren't upserted
	//
	Mode *Mode `default:"upsert" json:"mode"`
	// Scope configuration for upsert-prune-scope modes.
	// Defines how to find entities that should be pruned if not in the upsert payload.
	// The scope is resolved against the original event payload (not individual array items).
	//
	Scope *PruneScopeConfig `json:"scope,omitempty"`
	// Field mapping definitions
	Fields []IntegrationEntityField `json:"fields"`
}

func (i IntegrationEntity) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *IntegrationEntity) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *IntegrationEntity) GetEntitySchema() string {
	if i == nil {
		return ""
	}
	return i.EntitySchema
}

func (i *IntegrationEntity) GetUniqueIds() []string {
	if i == nil {
		return []string{}
	}
	return i.UniqueIds
}

func (i *IntegrationEntity) GetJsonataExpression() *string {
	if i == nil {
		return nil
	}
	return i.JsonataExpression
}

func (i *IntegrationEntity) GetEnabled() *Enabled {
	if i == nil {
		return nil
	}
	return i.Enabled
}

func (i *IntegrationEntity) GetMode() *Mode {
	if i == nil {
		return nil
	}
	return i.Mode
}

func (i *IntegrationEntity) GetScope() *PruneScopeConfig {
	if i == nil {
		return nil
	}
	return i.Scope
}

func (i *IntegrationEntity) GetFields() []IntegrationEntityField {
	if i == nil {
		return []IntegrationEntityField{}
	}
	return i.Fields
}
