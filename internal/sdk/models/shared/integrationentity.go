// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"errors"
	"fmt"
	"github.com/epilot-dev/terraform-provider-epilot-erp-integration/internal/sdk/internal/utils"
)

type EnabledType string

const (
	EnabledTypeBoolean EnabledType = "boolean"
	EnabledTypeStr     EnabledType = "str"
)

// Enabled - Controls whether this entity mapping should be processed. Can be a boolean or a JSONata expression (string) that evaluates to a boolean.
type Enabled struct {
	Boolean *bool   `queryParam:"inline" union:"member"`
	Str     *string `queryParam:"inline" union:"member"`

	Type EnabledType
}

func CreateEnabledBoolean(boolean bool) Enabled {
	typ := EnabledTypeBoolean

	return Enabled{
		Boolean: &boolean,
		Type:    typ,
	}
}

func CreateEnabledStr(str string) Enabled {
	typ := EnabledTypeStr

	return Enabled{
		Str:  &str,
		Type: typ,
	}
}

func (u *Enabled) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  EnabledTypeBoolean,
			Value: &boolean,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  EnabledTypeStr,
			Value: &str,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Enabled", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Enabled", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(EnabledType)
	switch best.Type {
	case EnabledTypeBoolean:
		u.Boolean = best.Value.(*bool)
		return nil
	case EnabledTypeStr:
		u.Str = best.Value.(*string)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Enabled", string(data))
}

func (u Enabled) MarshalJSON() ([]byte, error) {
	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type Enabled: all fields are null")
}

type IntegrationEntity struct {
	// Target entity schema (e.g., 'contact', 'contract')
	EntitySchema string `json:"entity_schema"`
	// Array of attribute names that uniquely identify this entity.
	// The _type hint for repeatable fields (e.g., email, phone) should be specified
	// on the corresponding field definition in the fields array.
	//
	UniqueIds []string `json:"unique_ids"`
	// Optional JSONata expression to pre-process the event data before field mapping
	JsonataExpression *string `json:"jsonataExpression,omitempty"`
	// Controls whether this entity mapping should be processed. Can be a boolean or a JSONata expression (string) that evaluates to a boolean.
	Enabled *Enabled `json:"enabled,omitempty"`
	// Field mapping definitions
	Fields []IntegrationEntityField `json:"fields"`
}

func (i IntegrationEntity) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *IntegrationEntity) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *IntegrationEntity) GetEntitySchema() string {
	if i == nil {
		return ""
	}
	return i.EntitySchema
}

func (i *IntegrationEntity) GetUniqueIds() []string {
	if i == nil {
		return []string{}
	}
	return i.UniqueIds
}

func (i *IntegrationEntity) GetJsonataExpression() *string {
	if i == nil {
		return nil
	}
	return i.JsonataExpression
}

func (i *IntegrationEntity) GetEnabled() *Enabled {
	if i == nil {
		return nil
	}
	return i.Enabled
}

func (i *IntegrationEntity) GetFields() []IntegrationEntityField {
	if i == nil {
		return []IntegrationEntityField{}
	}
	return i.Fields
}
