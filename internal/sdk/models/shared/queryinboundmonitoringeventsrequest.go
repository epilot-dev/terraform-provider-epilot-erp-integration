// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/epilot-dev/terraform-provider-epilot-erp-integration/internal/sdk/internal/utils"
	"time"
)

// QueryInboundMonitoringEventsRequestEventType - Filter by event type
type QueryInboundMonitoringEventsRequestEventType string

const (
	QueryInboundMonitoringEventsRequestEventTypeCreate  QueryInboundMonitoringEventsRequestEventType = "CREATE"
	QueryInboundMonitoringEventsRequestEventTypeUpdate  QueryInboundMonitoringEventsRequestEventType = "UPDATE"
	QueryInboundMonitoringEventsRequestEventTypeDelete  QueryInboundMonitoringEventsRequestEventType = "DELETE"
	QueryInboundMonitoringEventsRequestEventTypeTrigger QueryInboundMonitoringEventsRequestEventType = "TRIGGER"
)

func (e QueryInboundMonitoringEventsRequestEventType) ToPointer() *QueryInboundMonitoringEventsRequestEventType {
	return &e
}
func (e *QueryInboundMonitoringEventsRequestEventType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CREATE":
		fallthrough
	case "UPDATE":
		fallthrough
	case "DELETE":
		fallthrough
	case "TRIGGER":
		*e = QueryInboundMonitoringEventsRequestEventType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for QueryInboundMonitoringEventsRequestEventType: %v", v)
	}
}

// SyncType - Filter by sync type
type SyncType string

const (
	SyncTypeEntity         SyncType = "entity"
	SyncTypeMeterReading   SyncType = "meter_reading"
	SyncTypeWebhook        SyncType = "webhook"
	SyncTypeAPIDeprecation SyncType = "api_deprecation"
)

func (e SyncType) ToPointer() *SyncType {
	return &e
}
func (e *SyncType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "entity":
		fallthrough
	case "meter_reading":
		fallthrough
	case "webhook":
		fallthrough
	case "api_deprecation":
		*e = SyncType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SyncType: %v", v)
	}
}

// QueryInboundMonitoringEventsRequestStatus - Filter by processing status
type QueryInboundMonitoringEventsRequestStatus string

const (
	QueryInboundMonitoringEventsRequestStatusSuccess QueryInboundMonitoringEventsRequestStatus = "success"
	QueryInboundMonitoringEventsRequestStatusError   QueryInboundMonitoringEventsRequestStatus = "error"
	QueryInboundMonitoringEventsRequestStatusSkipped QueryInboundMonitoringEventsRequestStatus = "skipped"
	QueryInboundMonitoringEventsRequestStatusWarning QueryInboundMonitoringEventsRequestStatus = "warning"
)

func (e QueryInboundMonitoringEventsRequestStatus) ToPointer() *QueryInboundMonitoringEventsRequestStatus {
	return &e
}
func (e *QueryInboundMonitoringEventsRequestStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "success":
		fallthrough
	case "error":
		fallthrough
	case "skipped":
		fallthrough
	case "warning":
		*e = QueryInboundMonitoringEventsRequestStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for QueryInboundMonitoringEventsRequestStatus: %v", v)
	}
}

// ErrorCategory - Filter by error category (only applicable when status=error)
type ErrorCategory string

const (
	ErrorCategoryValidation    ErrorCategory = "validation"
	ErrorCategoryConfiguration ErrorCategory = "configuration"
	ErrorCategoryDownstreamAPI ErrorCategory = "downstream_api"
	ErrorCategoryTimeout       ErrorCategory = "timeout"
	ErrorCategorySystem        ErrorCategory = "system"
)

func (e ErrorCategory) ToPointer() *ErrorCategory {
	return &e
}
func (e *ErrorCategory) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "validation":
		fallthrough
	case "configuration":
		fallthrough
	case "downstream_api":
		fallthrough
	case "timeout":
		fallthrough
	case "system":
		*e = ErrorCategory(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ErrorCategory: %v", v)
	}
}

// QueryInboundMonitoringEventsRequestCursor - Cursor for pagination
type QueryInboundMonitoringEventsRequestCursor struct {
	// Timestamp from the last event in the previous page
	CompletedAt *time.Time `json:"completed_at,omitempty"`
	// Event ID from the last event in the previous page
	EventID *string `json:"event_id,omitempty"`
}

func (q QueryInboundMonitoringEventsRequestCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(q, "", false)
}

func (q *QueryInboundMonitoringEventsRequestCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &q, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (q *QueryInboundMonitoringEventsRequestCursor) GetCompletedAt() *time.Time {
	if q == nil {
		return nil
	}
	return q.CompletedAt
}

func (q *QueryInboundMonitoringEventsRequestCursor) GetEventID() *string {
	if q == nil {
		return nil
	}
	return q.EventID
}

type QueryInboundMonitoringEventsRequest struct {
	// Filter by use case ID
	UseCaseID *string `json:"use_case_id,omitempty"`
	// Filter by event type
	EventType *QueryInboundMonitoringEventsRequestEventType `json:"event_type,omitempty"`
	// Filter by sync type
	SyncType *SyncType `json:"sync_type,omitempty"`
	// Filter by processing status
	Status *QueryInboundMonitoringEventsRequestStatus `json:"status,omitempty"`
	// Filter by error category (only applicable when status=error)
	ErrorCategory *ErrorCategory `json:"error_category,omitempty"`
	// Filter by correlation ID
	CorrelationID *string `json:"correlation_id,omitempty"`
	// Filter by object type (e.g., 'contract', 'meter')
	ObjectType *string `json:"object_type,omitempty"`
	// Filter by event name (alias for object_type)
	EventName *string `json:"event_name,omitempty"`
	// Filter by event ID to find a specific event
	EventID *string `json:"event_id,omitempty"`
	// Filter events from this date (inclusive)
	FromDate *time.Time `json:"from_date,omitempty"`
	// Filter events until this date (inclusive)
	ToDate *time.Time `json:"to_date,omitempty"`
	// Maximum number of results to return
	Limit *int64 `default:"50" json:"limit"`
	// Cursor for pagination
	Cursor *QueryInboundMonitoringEventsRequestCursor `json:"cursor,omitempty"`
}

func (q QueryInboundMonitoringEventsRequest) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(q, "", false)
}

func (q *QueryInboundMonitoringEventsRequest) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &q, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (q *QueryInboundMonitoringEventsRequest) GetUseCaseID() *string {
	if q == nil {
		return nil
	}
	return q.UseCaseID
}

func (q *QueryInboundMonitoringEventsRequest) GetEventType() *QueryInboundMonitoringEventsRequestEventType {
	if q == nil {
		return nil
	}
	return q.EventType
}

func (q *QueryInboundMonitoringEventsRequest) GetSyncType() *SyncType {
	if q == nil {
		return nil
	}
	return q.SyncType
}

func (q *QueryInboundMonitoringEventsRequest) GetStatus() *QueryInboundMonitoringEventsRequestStatus {
	if q == nil {
		return nil
	}
	return q.Status
}

func (q *QueryInboundMonitoringEventsRequest) GetErrorCategory() *ErrorCategory {
	if q == nil {
		return nil
	}
	return q.ErrorCategory
}

func (q *QueryInboundMonitoringEventsRequest) GetCorrelationID() *string {
	if q == nil {
		return nil
	}
	return q.CorrelationID
}

func (q *QueryInboundMonitoringEventsRequest) GetObjectType() *string {
	if q == nil {
		return nil
	}
	return q.ObjectType
}

func (q *QueryInboundMonitoringEventsRequest) GetEventName() *string {
	if q == nil {
		return nil
	}
	return q.EventName
}

func (q *QueryInboundMonitoringEventsRequest) GetEventID() *string {
	if q == nil {
		return nil
	}
	return q.EventID
}

func (q *QueryInboundMonitoringEventsRequest) GetFromDate() *time.Time {
	if q == nil {
		return nil
	}
	return q.FromDate
}

func (q *QueryInboundMonitoringEventsRequest) GetToDate() *time.Time {
	if q == nil {
		return nil
	}
	return q.ToDate
}

func (q *QueryInboundMonitoringEventsRequest) GetLimit() *int64 {
	if q == nil {
		return nil
	}
	return q.Limit
}

func (q *QueryInboundMonitoringEventsRequest) GetCursor() *QueryInboundMonitoringEventsRequestCursor {
	if q == nil {
		return nil
	}
	return q.Cursor
}
