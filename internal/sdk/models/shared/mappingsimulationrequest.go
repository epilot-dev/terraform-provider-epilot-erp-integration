// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/epilot-dev/terraform-provider-epilot-erp-integration/internal/sdk/internal/utils"
)

type MappingConfigurationType string

const (
	MappingConfigurationTypeIntegrationConfigurationV1 MappingConfigurationType = "IntegrationConfigurationV1"
	MappingConfigurationTypeIntegrationConfigurationV2 MappingConfigurationType = "IntegrationConfigurationV2"
)

type MappingConfiguration struct {
	IntegrationConfigurationV1 *IntegrationConfigurationV1 `queryParam:"inline" union:"member"`
	IntegrationConfigurationV2 *IntegrationConfigurationV2 `queryParam:"inline" union:"member"`

	Type MappingConfigurationType
}

func CreateMappingConfigurationIntegrationConfigurationV1(integrationConfigurationV1 IntegrationConfigurationV1) MappingConfiguration {
	typ := MappingConfigurationTypeIntegrationConfigurationV1

	return MappingConfiguration{
		IntegrationConfigurationV1: &integrationConfigurationV1,
		Type:                       typ,
	}
}

func CreateMappingConfigurationIntegrationConfigurationV2(integrationConfigurationV2 IntegrationConfigurationV2) MappingConfiguration {
	typ := MappingConfigurationTypeIntegrationConfigurationV2

	return MappingConfiguration{
		IntegrationConfigurationV2: &integrationConfigurationV2,
		Type:                       typ,
	}
}

func (u *MappingConfiguration) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var integrationConfigurationV1 IntegrationConfigurationV1 = IntegrationConfigurationV1{}
	if err := utils.UnmarshalJSON(data, &integrationConfigurationV1, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MappingConfigurationTypeIntegrationConfigurationV1,
			Value: &integrationConfigurationV1,
		})
	}

	var integrationConfigurationV2 IntegrationConfigurationV2 = IntegrationConfigurationV2{}
	if err := utils.UnmarshalJSON(data, &integrationConfigurationV2, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MappingConfigurationTypeIntegrationConfigurationV2,
			Value: &integrationConfigurationV2,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MappingConfiguration", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MappingConfiguration", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(MappingConfigurationType)
	switch best.Type {
	case MappingConfigurationTypeIntegrationConfigurationV1:
		u.IntegrationConfigurationV1 = best.Value.(*IntegrationConfigurationV1)
		return nil
	case MappingConfigurationTypeIntegrationConfigurationV2:
		u.IntegrationConfigurationV2 = best.Value.(*IntegrationConfigurationV2)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MappingConfiguration", string(data))
}

func (u MappingConfiguration) MarshalJSON() ([]byte, error) {
	if u.IntegrationConfigurationV1 != nil {
		return utils.MarshalJSON(u.IntegrationConfigurationV1, "", true)
	}

	if u.IntegrationConfigurationV2 != nil {
		return utils.MarshalJSON(u.IntegrationConfigurationV2, "", true)
	}

	return nil, errors.New("could not marshal union type MappingConfiguration: all fields are null")
}

// MappingSimulationRequestFormat - Format of the payload data
type MappingSimulationRequestFormat string

const (
	MappingSimulationRequestFormatJSON MappingSimulationRequestFormat = "json"
	MappingSimulationRequestFormatXML  MappingSimulationRequestFormat = "xml"
)

func (e MappingSimulationRequestFormat) ToPointer() *MappingSimulationRequestFormat {
	return &e
}
func (e *MappingSimulationRequestFormat) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "json":
		fallthrough
	case "xml":
		*e = MappingSimulationRequestFormat(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MappingSimulationRequestFormat: %v", v)
	}
}

type MappingSimulationRequestPayloadType string

const (
	MappingSimulationRequestPayloadTypeStr      MappingSimulationRequestPayloadType = "str"
	MappingSimulationRequestPayloadTypeMapOfAny MappingSimulationRequestPayloadType = "mapOfAny"
)

// MappingSimulationRequestPayload - The object data payload - can be either a serialized string or a direct JSON object
type MappingSimulationRequestPayload struct {
	Str      *string        `queryParam:"inline" union:"member"`
	MapOfAny map[string]any `queryParam:"inline" union:"member"`

	Type MappingSimulationRequestPayloadType
}

func CreateMappingSimulationRequestPayloadStr(str string) MappingSimulationRequestPayload {
	typ := MappingSimulationRequestPayloadTypeStr

	return MappingSimulationRequestPayload{
		Str:  &str,
		Type: typ,
	}
}

func CreateMappingSimulationRequestPayloadMapOfAny(mapOfAny map[string]any) MappingSimulationRequestPayload {
	typ := MappingSimulationRequestPayloadTypeMapOfAny

	return MappingSimulationRequestPayload{
		MapOfAny: mapOfAny,
		Type:     typ,
	}
}

func (u *MappingSimulationRequestPayload) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MappingSimulationRequestPayloadTypeStr,
			Value: &str,
		})
	}

	var mapOfAny map[string]any = map[string]any{}
	if err := utils.UnmarshalJSON(data, &mapOfAny, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  MappingSimulationRequestPayloadTypeMapOfAny,
			Value: mapOfAny,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MappingSimulationRequestPayload", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for MappingSimulationRequestPayload", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(MappingSimulationRequestPayloadType)
	switch best.Type {
	case MappingSimulationRequestPayloadTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case MappingSimulationRequestPayloadTypeMapOfAny:
		u.MapOfAny = best.Value.(map[string]any)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MappingSimulationRequestPayload", string(data))
}

func (u MappingSimulationRequestPayload) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.MapOfAny != nil {
		return utils.MarshalJSON(u.MapOfAny, "", true)
	}

	return nil, errors.New("could not marshal union type MappingSimulationRequestPayload: all fields are null")
}

type MappingSimulationRequest struct {
	MappingConfiguration MappingConfiguration `json:"mapping_configuration"`
	// Type of the object/event being mapped.
	// For v1.0: must match a key in mapping_configuration.mapping.objects
	// For v2.0: must match a key in mapping_configuration.mapping.events
	//
	ObjectType string `json:"object_type"`
	// Format of the payload data
	Format *MappingSimulationRequestFormat `default:"json" json:"format"`
	// The object data payload - can be either a serialized string or a direct JSON object
	Payload MappingSimulationRequestPayload `json:"payload"`
}

func (m MappingSimulationRequest) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *MappingSimulationRequest) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (m *MappingSimulationRequest) GetMappingConfiguration() MappingConfiguration {
	if m == nil {
		return MappingConfiguration{}
	}
	return m.MappingConfiguration
}

func (m *MappingSimulationRequest) GetObjectType() string {
	if m == nil {
		return ""
	}
	return m.ObjectType
}

func (m *MappingSimulationRequest) GetFormat() *MappingSimulationRequestFormat {
	if m == nil {
		return nil
	}
	return m.Format
}

func (m *MappingSimulationRequest) GetPayload() MappingSimulationRequestPayload {
	if m == nil {
		return MappingSimulationRequestPayload{}
	}
	return m.Payload
}
