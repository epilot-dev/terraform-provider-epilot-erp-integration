// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/epilot-dev/terraform-provider-epilot-erp-integration/internal/sdk/internal/utils"
	"time"
)

// EventType - Type of event (create, update, delete)
type EventType string

const (
	EventTypeCreate EventType = "CREATE"
	EventTypeUpdate EventType = "UPDATE"
	EventTypeDelete EventType = "DELETE"
)

func (e EventType) ToPointer() *EventType {
	return &e
}
func (e *EventType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CREATE":
		fallthrough
	case "UPDATE":
		fallthrough
	case "DELETE":
		*e = EventType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for EventType: %v", v)
	}
}

// Format of the payload data
type Format string

const (
	FormatJSON Format = "json"
	FormatXML  Format = "xml"
)

func (e Format) ToPointer() *Format {
	return &e
}
func (e *Format) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "json":
		fallthrough
	case "xml":
		*e = Format(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Format: %v", v)
	}
}

type PayloadType string

const (
	PayloadTypeStr      PayloadType = "str"
	PayloadTypeMapOfAny PayloadType = "mapOfAny"
)

// Payload - The object data payload - can be either a serialized string or a direct JSON object
type Payload struct {
	Str      *string        `queryParam:"inline" union:"member"`
	MapOfAny map[string]any `queryParam:"inline" union:"member"`

	Type PayloadType
}

func CreatePayloadStr(str string) Payload {
	typ := PayloadTypeStr

	return Payload{
		Str:  &str,
		Type: typ,
	}
}

func CreatePayloadMapOfAny(mapOfAny map[string]any) Payload {
	typ := PayloadTypeMapOfAny

	return Payload{
		MapOfAny: mapOfAny,
		Type:     typ,
	}
}

func (u *Payload) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  PayloadTypeStr,
			Value: &str,
		})
	}

	var mapOfAny map[string]any = map[string]any{}
	if err := utils.UnmarshalJSON(data, &mapOfAny, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  PayloadTypeMapOfAny,
			Value: mapOfAny,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Payload", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Payload", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(PayloadType)
	switch best.Type {
	case PayloadTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case PayloadTypeMapOfAny:
		u.MapOfAny = best.Value.(map[string]any)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Payload", string(data))
}

func (u Payload) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.MapOfAny != nil {
		return utils.MarshalJSON(u.MapOfAny, "", true)
	}

	return nil, errors.New("could not marshal union type Payload: all fields are null")
}

type ErpEvent struct {
	// Type of event (create, update, delete)
	EventType EventType `json:"event_type"`
	// Type of the object being updated (business_partner, contract_account, etc.). Corresponds to "Event Name" from the integration UI.
	ObjectType string `json:"object_type"`
	// Timestamp when the event occurred
	Timestamp time.Time `json:"timestamp"`
	// Format of the payload data
	Format *Format `default:"json" json:"format"`
	// The object data payload - can be either a serialized string or a direct JSON object
	Payload Payload `json:"payload"`
	// Optional unique identifier for idempotency - prevents duplicate processing of the same event within 24 hours in context of the same integration. Must contain only alphanumeric characters, hyphens, and underscores.
	//
	DeduplicationID *string `json:"deduplication_id,omitempty"`
}

func (e ErpEvent) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ErpEvent) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (e *ErpEvent) GetEventType() EventType {
	if e == nil {
		return EventType("")
	}
	return e.EventType
}

func (e *ErpEvent) GetObjectType() string {
	if e == nil {
		return ""
	}
	return e.ObjectType
}

func (e *ErpEvent) GetTimestamp() time.Time {
	if e == nil {
		return time.Time{}
	}
	return e.Timestamp
}

func (e *ErpEvent) GetFormat() *Format {
	if e == nil {
		return nil
	}
	return e.Format
}

func (e *ErpEvent) GetPayload() Payload {
	if e == nil {
		return Payload{}
	}
	return e.Payload
}

func (e *ErpEvent) GetDeduplicationID() *string {
	if e == nil {
		return nil
	}
	return e.DeduplicationID
}
