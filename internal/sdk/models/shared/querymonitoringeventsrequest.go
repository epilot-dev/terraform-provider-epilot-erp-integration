// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/epilot-dev/terraform-provider-epilot-erp-integration/internal/sdk/internal/utils"
	"time"
)

// Direction - Filter by sync direction
type Direction string

const (
	DirectionInbound  Direction = "inbound"
	DirectionOutbound Direction = "outbound"
)

func (e Direction) ToPointer() *Direction {
	return &e
}
func (e *Direction) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "inbound":
		fallthrough
	case "outbound":
		*e = Direction(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Direction: %v", v)
	}
}

// QueryMonitoringEventsRequestEventType - Filter by event type
type QueryMonitoringEventsRequestEventType string

const (
	QueryMonitoringEventsRequestEventTypeCreate  QueryMonitoringEventsRequestEventType = "CREATE"
	QueryMonitoringEventsRequestEventTypeUpdate  QueryMonitoringEventsRequestEventType = "UPDATE"
	QueryMonitoringEventsRequestEventTypeDelete  QueryMonitoringEventsRequestEventType = "DELETE"
	QueryMonitoringEventsRequestEventTypeTrigger QueryMonitoringEventsRequestEventType = "TRIGGER"
)

func (e QueryMonitoringEventsRequestEventType) ToPointer() *QueryMonitoringEventsRequestEventType {
	return &e
}
func (e *QueryMonitoringEventsRequestEventType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CREATE":
		fallthrough
	case "UPDATE":
		fallthrough
	case "DELETE":
		fallthrough
	case "TRIGGER":
		*e = QueryMonitoringEventsRequestEventType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for QueryMonitoringEventsRequestEventType: %v", v)
	}
}

// SyncType - Filter by sync type
type SyncType string

const (
	SyncTypeEntity       SyncType = "entity"
	SyncTypeMeterReading SyncType = "meter_reading"
	SyncTypeWebhook      SyncType = "webhook"
)

func (e SyncType) ToPointer() *SyncType {
	return &e
}
func (e *SyncType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "entity":
		fallthrough
	case "meter_reading":
		fallthrough
	case "webhook":
		*e = SyncType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SyncType: %v", v)
	}
}

// QueryMonitoringEventsRequestStatus - Filter by processing status
type QueryMonitoringEventsRequestStatus string

const (
	QueryMonitoringEventsRequestStatusSuccess QueryMonitoringEventsRequestStatus = "success"
	QueryMonitoringEventsRequestStatusError   QueryMonitoringEventsRequestStatus = "error"
	QueryMonitoringEventsRequestStatusSkipped QueryMonitoringEventsRequestStatus = "skipped"
)

func (e QueryMonitoringEventsRequestStatus) ToPointer() *QueryMonitoringEventsRequestStatus {
	return &e
}
func (e *QueryMonitoringEventsRequestStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "success":
		fallthrough
	case "error":
		fallthrough
	case "skipped":
		*e = QueryMonitoringEventsRequestStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for QueryMonitoringEventsRequestStatus: %v", v)
	}
}

// ErrorCategory - Filter by error category (only applicable when status=error)
type ErrorCategory string

const (
	ErrorCategoryValidation      ErrorCategory = "validation"
	ErrorCategoryConfiguration   ErrorCategory = "configuration"
	ErrorCategoryDownstreamAPI   ErrorCategory = "downstream_api"
	ErrorCategoryTimeout         ErrorCategory = "timeout"
	ErrorCategorySystem          ErrorCategory = "system"
	ErrorCategoryWebhookDelivery ErrorCategory = "webhook_delivery"
)

func (e ErrorCategory) ToPointer() *ErrorCategory {
	return &e
}
func (e *ErrorCategory) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "validation":
		fallthrough
	case "configuration":
		fallthrough
	case "downstream_api":
		fallthrough
	case "timeout":
		fallthrough
	case "system":
		fallthrough
	case "webhook_delivery":
		*e = ErrorCategory(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ErrorCategory: %v", v)
	}
}

// QueryMonitoringEventsRequestCursor - Cursor for pagination
type QueryMonitoringEventsRequestCursor struct {
	// Timestamp from the last event in the previous page
	CompletedAt *time.Time `json:"completed_at,omitempty"`
	// Event ID from the last event in the previous page
	EventID *string `json:"event_id,omitempty"`
}

func (q QueryMonitoringEventsRequestCursor) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(q, "", false)
}

func (q *QueryMonitoringEventsRequestCursor) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &q, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (q *QueryMonitoringEventsRequestCursor) GetCompletedAt() *time.Time {
	if q == nil {
		return nil
	}
	return q.CompletedAt
}

func (q *QueryMonitoringEventsRequestCursor) GetEventID() *string {
	if q == nil {
		return nil
	}
	return q.EventID
}

type QueryMonitoringEventsRequest struct {
	// Filter by use case ID
	UseCaseID *string `json:"use_case_id,omitempty"`
	// Filter by sync direction
	Direction *Direction `json:"direction,omitempty"`
	// Filter by event type
	EventType *QueryMonitoringEventsRequestEventType `json:"event_type,omitempty"`
	// Filter by sync type
	SyncType *SyncType `json:"sync_type,omitempty"`
	// Filter by processing status
	Status *QueryMonitoringEventsRequestStatus `json:"status,omitempty"`
	// Filter by error category (only applicable when status=error)
	ErrorCategory *ErrorCategory `json:"error_category,omitempty"`
	// Filter by correlation ID
	CorrelationID *string `json:"correlation_id,omitempty"`
	// Filter by object type (e.g., 'contract', 'meter')
	ObjectType *string `json:"object_type,omitempty"`
	// Filter by event ID to find a specific event
	EventID *string `json:"event_id,omitempty"`
	// Filter events from this date (inclusive)
	FromDate *time.Time `json:"from_date,omitempty"`
	// Filter events until this date (inclusive)
	ToDate *time.Time `json:"to_date,omitempty"`
	// Maximum number of results to return
	Limit *int64 `default:"50" json:"limit"`
	// Cursor for pagination
	Cursor *QueryMonitoringEventsRequestCursor `json:"cursor,omitempty"`
}

func (q QueryMonitoringEventsRequest) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(q, "", false)
}

func (q *QueryMonitoringEventsRequest) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &q, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (q *QueryMonitoringEventsRequest) GetUseCaseID() *string {
	if q == nil {
		return nil
	}
	return q.UseCaseID
}

func (q *QueryMonitoringEventsRequest) GetDirection() *Direction {
	if q == nil {
		return nil
	}
	return q.Direction
}

func (q *QueryMonitoringEventsRequest) GetEventType() *QueryMonitoringEventsRequestEventType {
	if q == nil {
		return nil
	}
	return q.EventType
}

func (q *QueryMonitoringEventsRequest) GetSyncType() *SyncType {
	if q == nil {
		return nil
	}
	return q.SyncType
}

func (q *QueryMonitoringEventsRequest) GetStatus() *QueryMonitoringEventsRequestStatus {
	if q == nil {
		return nil
	}
	return q.Status
}

func (q *QueryMonitoringEventsRequest) GetErrorCategory() *ErrorCategory {
	if q == nil {
		return nil
	}
	return q.ErrorCategory
}

func (q *QueryMonitoringEventsRequest) GetCorrelationID() *string {
	if q == nil {
		return nil
	}
	return q.CorrelationID
}

func (q *QueryMonitoringEventsRequest) GetObjectType() *string {
	if q == nil {
		return nil
	}
	return q.ObjectType
}

func (q *QueryMonitoringEventsRequest) GetEventID() *string {
	if q == nil {
		return nil
	}
	return q.EventID
}

func (q *QueryMonitoringEventsRequest) GetFromDate() *time.Time {
	if q == nil {
		return nil
	}
	return q.FromDate
}

func (q *QueryMonitoringEventsRequest) GetToDate() *time.Time {
	if q == nil {
		return nil
	}
	return q.ToDate
}

func (q *QueryMonitoringEventsRequest) GetLimit() *int64 {
	if q == nil {
		return nil
	}
	return q.Limit
}

func (q *QueryMonitoringEventsRequest) GetCursor() *QueryMonitoringEventsRequestCursor {
	if q == nil {
		return nil
	}
	return q.Cursor
}
