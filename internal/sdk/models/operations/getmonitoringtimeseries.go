// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"github.com/epilot-dev/terraform-provider-epilot-erp-integration/internal/sdk/internal/utils"
	"github.com/epilot-dev/terraform-provider-epilot-erp-integration/internal/sdk/models/shared"
	"net/http"
	"time"
)

type GetMonitoringTimeSeriesRequest struct {
	// The integration ID
	IntegrationID                  string                                `pathParam:"style=simple,explode=false,name=integrationId"`
	GetMonitoringTimeSeriesRequest shared.GetMonitoringTimeSeriesRequest `request:"mediaType=application/json"`
}

func (g *GetMonitoringTimeSeriesRequest) GetIntegrationID() string {
	if g == nil {
		return ""
	}
	return g.IntegrationID
}

func (g *GetMonitoringTimeSeriesRequest) GetGetMonitoringTimeSeriesRequest() shared.GetMonitoringTimeSeriesRequest {
	if g == nil {
		return shared.GetMonitoringTimeSeriesRequest{}
	}
	return g.GetMonitoringTimeSeriesRequest
}

// Interval - The time bucket interval used for aggregation
type Interval string

const (
	IntervalFivem   Interval = "5m"
	IntervalTenm    Interval = "10m"
	IntervalThirtym Interval = "30m"
	IntervalOneh    Interval = "1h"
	IntervalThreeh  Interval = "3h"
	IntervalOned    Interval = "1d"
)

func (e Interval) ToPointer() *Interval {
	return &e
}
func (e *Interval) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "5m":
		fallthrough
	case "10m":
		fallthrough
	case "30m":
		fallthrough
	case "1h":
		fallthrough
	case "3h":
		fallthrough
	case "1d":
		*e = Interval(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Interval: %v", v)
	}
}

// GetMonitoringTimeSeriesResponseBody - Time-series aggregated event counts retrieved successfully
type GetMonitoringTimeSeriesResponseBody struct {
	// The time bucket interval used for aggregation
	Interval Interval `json:"interval"`
	// Start date of the time series
	FromDate time.Time `json:"from_date"`
	// End date of the time series
	ToDate time.Time `json:"to_date"`
	// List of time-series buckets with event counts
	Buckets []shared.TimeSeriesBucket `json:"buckets"`
}

func (g GetMonitoringTimeSeriesResponseBody) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetMonitoringTimeSeriesResponseBody) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (g *GetMonitoringTimeSeriesResponseBody) GetInterval() Interval {
	if g == nil {
		return Interval("")
	}
	return g.Interval
}

func (g *GetMonitoringTimeSeriesResponseBody) GetFromDate() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.FromDate
}

func (g *GetMonitoringTimeSeriesResponseBody) GetToDate() time.Time {
	if g == nil {
		return time.Time{}
	}
	return g.ToDate
}

func (g *GetMonitoringTimeSeriesResponseBody) GetBuckets() []shared.TimeSeriesBucket {
	if g == nil {
		return []shared.TimeSeriesBucket{}
	}
	return g.Buckets
}

type GetMonitoringTimeSeriesResponse struct {
	// HTTP response content type for this operation
	ContentType string
	// HTTP response status code for this operation
	StatusCode int
	// Raw HTTP response; suitable for custom response parsing
	RawResponse *http.Response
	// Time-series aggregated event counts retrieved successfully
	Object *GetMonitoringTimeSeriesResponseBody
	// Bad request
	ErrorResponseBase *shared.ErrorResponseBase
}

func (g *GetMonitoringTimeSeriesResponse) GetContentType() string {
	if g == nil {
		return ""
	}
	return g.ContentType
}

func (g *GetMonitoringTimeSeriesResponse) GetStatusCode() int {
	if g == nil {
		return 0
	}
	return g.StatusCode
}

func (g *GetMonitoringTimeSeriesResponse) GetRawResponse() *http.Response {
	if g == nil {
		return nil
	}
	return g.RawResponse
}

func (g *GetMonitoringTimeSeriesResponse) GetObject() *GetMonitoringTimeSeriesResponseBody {
	if g == nil {
		return nil
	}
	return g.Object
}

func (g *GetMonitoringTimeSeriesResponse) GetErrorResponseBase() *shared.ErrorResponseBase {
	if g == nil {
		return nil
	}
	return g.ErrorResponseBase
}
